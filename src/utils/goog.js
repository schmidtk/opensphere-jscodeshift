const jscs = require('jscodeshift');
const path = require('path');

const config = require('config');
const fs = require('fs');

const {
  copyComments,
  createFindCallFn,
  createFindMemberExprObject,
  getUniqueVarName,
  isCall,
  isInComment,
  isReferenced,
  replaceInComments
} = require('./ast');

const {createCall, createMemberExpression, getWorkspacePath, memberExpressionToString} = require('./jscs');
const {getRootDescribe, isKarmaTest} = require('./karma');
const {logger} = require('./logger');

/**
 * Regular expression to detect @const JSDoc annotation.
 * @type {RegExp}
 */
const CONST_REGEXP = /@const([\s]+.*)?/;


/**
 * Loaded Closure dependencies, mapped by module name.
 * @type {!Object<string, !Object>}
 */
const dependencies = {};


/**
 * If deps have been loaded.
 * @type {boolean}
 */
let depsLoaded = false;


/**
 * If Closure deps have been loaded.
 * @type {boolean}
 */
let googDepsLoaded = false;


/**
 * Path to the deps file.
 * @type {string}
 */
let depsPath = '';


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {!Array<string>} provides An array of strings with
 *     the names of the objects this file provides.
 * @param {!Array<string>} requires An array of strings with
 *     the names of the objects this file requires.
 * @param {!Object<string>=} loadFlags Parameters indicating
 *     how the file must be loaded.  The boolean 'true' is equivalent
 *     to {'module': 'goog'} for backwards-compatibility.  Valid properties
 *     and values include {'module': 'goog'} and {'lang': 'es6'}.
 */
const addDependency = (relPath, provides, requires, loadFlags = {}) => {
  if (provides && provides.length) {
    provides.forEach((moduleName) => {
      if (!dependencies[moduleName]) {
        const modulePath = relPath.replace(/^(\.\.\/)*((modules|workspace)\/)?/, '');
        const workspacePath = getWorkspacePath();
        const fullPath = path.join(workspacePath, modulePath);

        dependencies[moduleName] = {
          moduleName,
          moduleType: loadFlags.module,
          path: modulePath,
          fullPath,
          requires
        };
      }
    });
  }
};

// Create a global goog.addDependency call so a Closure deps file can be loaded with require.
global.goog = {addDependency};


/**
 * Get the dependency info for a module.
 * @param {string} moduleName The module name.
 * @param {boolean} searchParents If parent modules should be searched, defaults to false.
 * @return {Object|undefined} The dependency, or undefined if not loaded.
 */
const getDependency = (moduleName, searchParents = false) => {
  if (!depsLoaded) {
    loadDeps();
  }

  let dep = dependencies[moduleName]
  if (!dep && searchParents) {
    const parts = moduleName.split('.');

    while (!dep && parts.length > 1) {
      parts.pop();

      const parentModule = parts.join('.');
      dep = dependencies[parentModule];
    }
  }

  return dep;
};


/**
 * Get the loaded dependency map.
 * @return {!Object}
 */
const getDependencies = () => dependencies;


/**
 * Load goog dependencies from a deps file, generated by depswriter.py.
 * @param {boolean=} loadGoog If Closure deps should also be loaded. Defaults to true.
 */
const loadDeps = (loadGoog = true) => {
  // Resolve the deps file from node_modules. This can be replaced in config/local.json to load deps for other projects.
  const depsFile = config.get('depsFile');
  depsPath = require.resolve(depsFile)

  if (!fs.existsSync(depsPath)) {
    throw new Error(`Deps file does not exist: ${depsFile}`);
  }

  if (!depsLoaded) {
    depsLoaded = true;
    require(depsPath);
  }

  if (loadGoog && !googDepsLoaded) {
    googDepsLoaded = true;

    // Resolve Closure deps relative to the base deps file, so the correct version of the Closure library is used.
    const googDepsPath = require.resolve('google-closure-library/closure/goog/deps', {paths: [path.dirname(depsPath)]});
    if (!fs.existsSync(googDepsPath)) {
      throw new Error('Unable to resolve Closure deps');
    }

    require(googDepsPath);
  }
};


/**
 * If a Closure dependency has a default export.
 * @param {Object} dependency
 * @return {boolean}
 */
const hasDefaultExport = (dependency) => {
  const depSource = fs.readFileSync(dependency.fullPath, 'utf-8');
  return /\sexport default /.test(depSource);
};


const getObjectProperty = (key, value) => {
  const property = jscs.property('init', jscs.identifier(key), value || jscs.identifier(key));
  property.shorthand = true;
  return property;
};


const getObjectProperties = (keys, values) => {
  return typeof keys === 'string' ? [getObjectProperty(keys, values)] :
      keys.map((key, idx, arr) => getObjectProperty(key, values ? values[idx] : undefined));
};


/**
 * Add goog.module exports to the source.
 * @param {NodePath} root The root node path.
 * @param {Array<string>|string} keys The export key(s). Use a string for default export, or array of strings for
 *                                    non-default exports.
 * @param {Array<Node>|Node} values Values to assign to the export(s).
 */
const addExports = (root, keys, values) => {
  const programs = root.find(jscs.Program);
  if (programs.length) {
    const program = programs.get().value;

    const existingAssignmentExpr = root.find(jscs.AssignmentExpression, {
      left: {type: 'Identifier', name: 'exports'}
    });

    let existingExports;
    if (existingAssignmentExpr.length) {
      existingExports = existingAssignmentExpr.get();

      // if the file is currently using a default export, convert it
      if (existingExports.value.right.type === 'Identifier') {
        const currentName = existingExports.value.right.name;
        existingExports.value.right = jscs.objectExpression([getObjectProperty(currentName)]);
      }
    }

    if (!existingExports && typeof keys === 'string' && !values) {
      // single default export
      const assignment = jscs.assignmentExpression('=', jscs.identifier('exports'), jscs.identifier(keys));
      program.body.push(jscs.expressionStatement(assignment));
    } else {
      // non-default exports
      const properties = getObjectProperties(keys, values);

      if (existingExports) {
        // add keys to existing exports
        const existingObjExpr = existingExports.value.right;
        existingObjExpr.properties = existingObjExpr.properties.concat(properties);
      } else {
        // create a new exports assignment
        const assignmentValue = jscs.objectExpression(properties);
        const assignment = jscs.assignmentExpression('=', jscs.identifier('exports'), assignmentValue);
        program.body.push(jscs.expressionStatement(assignment));
      }
    }
  }
};


/**
 * Get the goog exports assignment expression.
 * @param {NodePath} root The root node path.
 * @return {NodePath|undefined} The exports, or undefined if not found.
 */
const getGoogModuleExports = (root) => {
  let moduleExports;

  const exprPaths = root.find(jscs.AssignmentExpression, {
    left: {
      type: 'Identifier',
      name: 'exports'
    },
    operator: '='
  }).paths();

  if (exprPaths && exprPaths.length === 1) {
    moduleExports = exprPaths[0];
  }

  return moduleExports;
};


/**
 * If a node is a `goog.declareModuleId` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogDeclareModuleId = node => {
  return node.type === 'ExpressionStatement' && isCall(node.expression, 'goog.declareModuleId');
};


/**
 * If a node is a `goog.module.declareLegacyNamespace` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogDeclareLegacyNamespace = node => {
  return node.type === 'ExpressionStatement' && isCall(node.expression, 'goog.module.declareLegacyNamespace');
};


/**
 * If a node is a `goog.define` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogDefine = node => {
  return node.type === 'ExpressionStatement' && isCall(node.expression, 'goog.define');
};


/**
 * If a node is a `goog.module` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogModule = node => {
  return node.type === 'ExpressionStatement' && isCall(node.expression, 'goog.module');
};


/**
 * If a node is a `goog.require` variable assignment.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogModuleRequire = node => {
  return node.type === 'VariableDeclaration' && jscs.match(node, {
    declarations: [{
      type: 'VariableDeclarator',
      init: {
        type: 'CallExpression',
        callee: createFindMemberExprObject('goog.require')
      }
    }]
  });
};


/**
 * If a node is a `goog.requireType` variable assignment.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogModuleRequireType = node => {
  return node.type === 'VariableDeclaration' && jscs.match(node, {
    declarations: [{
      type: 'VariableDeclarator',
      init: {
        type: 'CallExpression',
        callee: createFindMemberExprObject('goog.requireType')
      }
    }]
  });
};


/**
 * If a node is a `goog.require` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogRequire = node => {
  return node.type === 'ExpressionStatement' && isCall(node.expression, 'goog.require');
};


/**
 * If a node is a `goog.require` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogRequireCall = node => {
  return node.type === 'CallExpression' && isCall(node, 'goog.require');
};


/**
 * If a node is a `goog.require` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogRequireTypeCall = node => {
  return node.type === 'CallExpression' && isCall(node, 'goog.requireType');
};


/**
 * If a node is a `goog.module.get` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogModuleGet = node => {
  return isCall(node, 'goog.module.get');
};


/**
 * If a node is a `goog.provide` call.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isGoogProvide = node => {
  return node.type === 'ExpressionStatement' && isCall(node.expression, 'goog.provide');
};


/**
 * If a node represents a Closure class constructor.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isClosureClass = node => {
  if (node && node.comments && node.comments.length === 1) {
    return node.comments[0].value.indexOf('@constructor') > -1;
  }
  return false;
};


/**
 * If a node represents a Closure class constructor.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isControllerClass = node => {
  if (isClosureClass(node)) {
    return node.comments[0].value.indexOf('@ngInject') > -1;
  }
  return false;
};


/**
 * If a node represents a Closure class constructor.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isDirective = node => {
  if (node && node.comments && node.comments.length === 1) {
    return node.comments[0].value.indexOf('angular.Directive') > -1;
  }
  return false;
};


/**
 * If a node represents an interface.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isInterface = node => {
  if (node && node.comments && node.comments.length === 1) {
    return node.comments[0].value.indexOf('@interface') > -1;
  }
  return false;
};


/**
 * If a node is marked constant in its comments.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isConst = (node) => {
  if (node && node.comments && node.comments.length === 1) {
    return CONST_REGEXP.test(node.comments[0].value);
  }
  return false;
};


/**
 * If a node is marked private in its comments.
 * @param {Node} node The node.
 * @return {boolean}
 */
const isPrivate = (node) => {
  if (node && node.comments && node.comments.length === 1) {
    return node.comments[0].value.indexOf('@private') > -1;
  }
  return false;
};


/**
 * If a root node is for a goog.declareModuleId file.
 * @param {Node} root The root node.
 * @return {boolean}
 */
const isESModuleFile = (root) => {
  const existing = root.find(jscs.ExpressionStatement, (path) => isGoogDeclareModuleId(path));
  return existing && existing.length;
};


/**
 * If a root node is for a goog.module file.
 * @param {Node} root The root node.
 * @return {boolean}
 */
const isGoogModuleFile = (root) => {
  const existing = root.find(jscs.ExpressionStatement, (path) => isGoogModule(path));
  return existing && existing.length;
};


/**
 * If a root node is for a Closure module (goog.module or goog.declareModuleId) file.
 * @param {Node} root The root node.
 * @return {boolean}
 */
const isModuleFile = (root) => {
  const existing = root.find(jscs.ExpressionStatement,
      (path) => isGoogModule(path) || isGoogDeclareModuleId(path));
  return existing && existing.length;
};


/**
 * Get the default export identifier from a var declaration assigned from a goog.require or goog.module.get.
 * @param {VariableDeclarator} varDecl The VariableDeclarator node.
 * @param {?string=} varName The name to use if a default export needs to be added.
 * @return {Identifier} The Identifier for the default export, or null if not found.
 */
const getDefaultExportId = (varDecl, varName = null) => {
  if (varDecl && varDecl.id) {
    if (varDecl.id.type === 'Identifier') {
      return varDecl.id;
    } else if (varDecl.id.type === 'ObjectPattern') {
      const props = varDecl.id.properties;
      const defaultProp = props.find((p) => p.key.name === 'default');
      if (defaultProp) {
        return defaultProp.value;
      } else if (varName) {
        const varIdentifier = jscs.identifier(varName);
        props.push(jscs.property('init', jscs.identifier('default'), varIdentifier));
        return varIdentifier;
      }
    }
  }

  return null;
};


/**
 * Add a goog.require statement if it doesn't already exist.
 * @param {Node} root The root node.
 * @param {string} toAdd The require to add.
 */
const addRequire = (root, toAdd) => {
  if (isModuleFile(root)) {
    replaceSrcGlobals(root, toAdd);
  } else {
    addLegacyRequire(root, toAdd);
  }
};


/**
 * Add a legacy goog.require statement (no return assignment) if it doesn't already exist.
 * @param {Node} root The root node.
 * @param {string} toAdd The require to add.
 */
const addLegacyRequire = (root, toAdd) => {
  const requires = root.find(jscs.ExpressionStatement, isGoogRequire);
  if (!requires.some(path => path.node.expression.arguments[0].value === toAdd)) {
    const program = root.find(jscs.Program).get();
    const programBody = program.value.body;
    for (let i = 0; i < programBody.length; i++) {
      const current = programBody[i];
      if (!isGoogModule(current) && !isGoogDeclareLegacyNamespace(current) && !isGoogProvide(current) &&
          !isGoogModuleRequire(current) && !isGoogModuleRequireType(current)) {
        const insertIndex = isGoogRequire(current) ? i + 1 : i;
        const callee = jscs.memberExpression(jscs.identifier('goog'), jscs.identifier('require'));
        const call = jscs.callExpression(callee, [jscs.literal(toAdd)]);
        programBody.splice(insertIndex, 0, jscs.expressionStatement(call));

        sortRequires(root);

        break;
      }
    }
  }
};


/**
 * Add a goog.module.get statement if it doesn't already exist.
 * @param {Node} root The root node.
 * @param {string} moduleName The module name.
 * @param {string} varName The variable name to assign to.
 */
const addModuleRequire = (root, moduleName, varName) => {
  let varIdentifier = null;

  // Search for goog.require('<moduleName>') calls. These can be either legacy or module-type requires.
  const existing = root.find(jscs.CallExpression,
      (path) => isGoogRequireCall(path) && path.arguments[0].value === moduleName);
  if (existing.length) {
    const requireCall = existing.get();
    if (requireCall.parent.value.type === 'ExpressionStatement') {
      // If the parent is an ExpressionStatement, this is a legacy require. Remove it and we'll add a module-type
      // require below.
      jscs(requireCall.parent).remove();
    } else {
      // Module in a VariableDeclarator, get/create the default export identifier.
      const varDeclarator = requireCall.parent.value;
      varIdentifier = getDefaultExportId(varDeclarator, varName);
    }
  }

  if (!varIdentifier) {
    // No module-type require was found, create one.
    varIdentifier = jscs.identifier(varName);

    const program = root.find(jscs.Program).get();
    const programBody = program.value.body;
    for (let i = 0; i < programBody.length; i++) {
      const current = programBody[i];
      //
      // Insert after:
      //   - goog.declareModuleId
      //   - import
      //   - goog.module
      //   - goog.module.declareLegacyNamespace
      //   - goog.provide
      //   - goog.require
      //
      if (!isGoogDeclareModuleId(current) && current.type !== 'ImportDeclaration' &&
          !isGoogModule(current) && !isGoogDeclareLegacyNamespace(current) &&
          !isGoogProvide(current) && !isGoogRequire(current)) {
        const call = createCall('goog.require', [jscs.literal(moduleName)]);
        const varDeclarator = jscs.variableDeclarator(varIdentifier, call);
        const varDeclaration = jscs.variableDeclaration('const', [varDeclarator]);
        programBody.splice(i, 0, varDeclaration);

        break;
      }
    }
  }

  return varIdentifier;
};


/**
 * Add a goog.module.get statement if it doesn't already exist.
 * @param {Node} root The root node.
 * @param {string} moduleName The module name.
 * @param {string} varName The variable name to assign to.
 */
const addGoogModuleGet = (root, moduleName, varName) => {
  const existing = jscs(root).find(jscs.CallExpression,
      (path) => isGoogModuleGet(path) && path.arguments[0].value === moduleName);
  if (existing.length) {
    const varDeclarator = existing.get().parent.value;
    return getDefaultExportId(varDeclarator, varName);
  } else {
    const describeBody = root.value.arguments[1].body.body;
    const call = createCall('goog.module.get', [jscs.literal(moduleName)]);
    const varIdentifier = jscs.identifier(varName);
    const varDeclarator = jscs.variableDeclarator(varIdentifier, call);
    const varDeclaration = jscs.variableDeclaration('const', [varDeclarator]);
    describeBody.splice(0, 0, varDeclaration);

    return varIdentifier;
  }
};


/**
 * Replace a legacy goog.require statement to use the module return value.
 * @param {Node} root The root node.
 * @param {string} toReplace The str to replace.
 * @param {?string} toReplaceAlt The str to require.
 * @param {?boolean} singleton if true, include getInstance() in call
 * @return {Identifier} The Identifier assigned to the require, or null if not found.
 */
const replaceLegacyRequire = (root, toReplace, toReplaceAlt, singleton) => {
  // remove existing goog.require calls for the module
  const expr = {
    expression: {
      callee: createFindMemberExprObject('goog.require'),
      arguments: [{value: toReplace}]
    }
  };
  root.find(jscs.ExpressionStatement, expr).remove();

  if (toReplaceAlt) {
    expr.expression.arguments = [{value: toReplaceAlt}];
    root.find(jscs.ExpressionStatement, expr).remove();
  }

  let requireCall;

  if (isReferenced(root, toReplace)) {
    // referenced in the file - use goog.require
    requireCall = 'require';
  } else if (isInComment(root, toReplace)) {
    // only referenced in comments - use goog.requireType
    requireCall = 'requireType';
  } else {
    // bail if the module isn't referenced in the file
    return null;
  }

  // create a variable name that doesn't shadow any local vars
  const varName = getUniqueVarName(root, toReplace);
  const varIdentifier = jscs.identifier(varName);
  const moduleName = toReplaceAlt || toReplace;

  const isTestFile = isKarmaTest(root);
  if (isModuleFile(root)) {
    // create the variable declaration
    const callee = jscs.memberExpression(jscs.identifier('goog'), jscs.identifier(requireCall));
    const call = jscs.callExpression(callee, [jscs.literal(moduleName)]);
    const varDeclarator = jscs.variableDeclarator(varIdentifier, call);
    const varDeclaration = jscs.variableDeclaration('const', [varDeclarator]);

    // insert the declaration after goog.module and legacy goog.require statements
    const program = root.find(jscs.Program).get();
    const programBody = program.value.body;
    for (let i = 0; i < programBody.length; i++) {
      const current = programBody[i];
      if (!isGoogDeclareModuleId(current) && current.type !== 'ImportDeclaration' &&
          !isGoogModule(current) && !isGoogDeclareLegacyNamespace(current) &&
          !isGoogProvide(current) && !isGoogRequire(current)) {
        programBody.splice(i, 0, varDeclaration);
        break;
      }
    }
  } else if (isTestFile) {
    addLegacyRequire(root, moduleName);
  }

  let replaceWith = isTestFile ? createMemberExpression(moduleName) : varIdentifier;

  // add .getInstance() if needed for the in-line replacements
  if (singleton === true) {
    replaceWith = jscs.memberExpression(replaceWith, jscs.identifier('getInstance'));
    replaceWith = jscs.callExpression(replaceWith, []);
  }

  // replace references to the fully qualified class name with the local variable name
  root.find(jscs.MemberExpression, createFindMemberExprObject(toReplace))
      .forEach(path => jscs(path).replaceWith(replaceWith));

  // replace references in comments
  replaceInComments(root, toReplace, varName);

  return varIdentifier;
};


/**
 * If the document is using a default export.
 * @param {NodePath} root The root node.
 */
const isDefaultExport = (root) => {
  const moduleExports = getGoogModuleExports(root);
  if (moduleExports) {
    const exportsType = moduleExports.value.right.type;
    return exportsType === 'Identifier';
  }

  return false;
};


/**
 * Find the declaration of a goog named export and create an ES6 named export declaration.
 * @param {NodePath} root The root node.
 * @param {Node} prop The exported property.
 */
const createNamedExport = (root, prop) => {
  if (prop && prop.value) {
    // If the property is shorthand or the value is an Identifier, find the reference in the file and export it inline
    if (prop.shorthand || prop.value.type === 'Identifier') {
      const propName = prop.value.name;

      const varDeclarations = root.find(jscs.VariableDeclaration, {
        declarations: [{
          type: 'VariableDeclarator',
          id: {name: propName}
        }]
      });

      if (varDeclarations && varDeclarations.length) {
        varDeclarations.forEach(exportNamedDeclaration);
      }

      const classDeclarations = root.find(jscs.ClassDeclaration, {
        id: {name: propName}
      });

      if (classDeclarations && classDeclarations.length) {
        classDeclarations.forEach((classDecl) => {
          exportNamedDeclaration(classDecl);
        });
      }
    }
  }
};


/**
 * Add a named export to a path node.
 * @param {NodePath} path The path node.
 */
const exportNamedDeclaration = (path) => {
  // Only replace variables assigned in the program body.
  if (path.parent.value.type === 'Program') {
    const namedExport = jscs.exportNamedDeclaration(path.value);
    copyComments(path.value, namedExport);

    jscs(path).replaceWith(namedExport);
  }
};


/**
 * Add a default export to a path node.
 * @param {NodePath} path The path node.
 */
 const exportDefaultDeclaration = (path) => {
  const defaultExport = jscs.exportDefaultDeclaration(path.value);
  copyComments(path.value, defaultExport);

  jscs(path).replaceWith(defaultExport);
};


/**
 * Replace goog.module exports with ES6 exports.
 * @param {NodePath} root The root node.
 * @param {string} moduleName The Closure module name.
 * @return {boolean} If the module is using a default export.
 */
const replaceModuleExportsWithEs6 = (root, moduleName) => {
  let isDefault = false;

  const moduleExports = getGoogModuleExports(root);
  if (moduleExports) {
    const exportsType = moduleExports.value.right.type;
    if (exportsType === 'Identifier') {
      const id = moduleExports.value.right;
      const classDecl = root.find(jscs.ClassDeclaration, {id: {name: id.name}});
      if (classDecl.length === 1) {
        // The default export is a class, so add the "export default" inline on the class declaration.
        exportDefaultDeclaration(classDecl.get());
        jscs(moduleExports.parent).remove();
      } else {
        // Replace the goog.module exports with an export default declaration.
        const exportDefaultDecl = jscs.exportDefaultDeclaration(id);
        jscs(moduleExports.parent).replaceWith(exportDefaultDecl);
      }

      isDefault = true;
    } else if (exportsType === 'ObjectExpression') {
      const exportedProps = moduleExports.value.right.properties;
      if (exportedProps && exportedProps.length) {
        //
        // Named exports should be using shorthand notation, while a default export object will not.
        //
        // Named exports:
        //
        //   exports = {EXPORT_1, export2, Export3};
        //
        // Default object export (typically used to export an enum):
        //
        //   exports = {
        //     EXPORT_1: 'value1',
        //     EXPORT_2: 'value2'
        //   }
        //
        exportedProps.forEach((prop) => {
          isDefault = isDefault || (prop && !prop.shorthand);
        });

        if (isDefault) {
          replaceGoogExportsWithDefault(moduleExports, moduleName);
        } else {
          exportedProps.forEach((prop) => {
            createNamedExport(root, prop);
          });

          // remove the exports expression
          jscs(moduleExports.parent).remove();
        }
      } else {
        logger.warn('No properties found in exports object.');
      }
    } else {
      replaceGoogExportsWithDefault(moduleExports, moduleName);
      isDefault = true;
    }
  }

  return isDefault;
};


/**
 * Assigns goog.module exports to a var that can be exported as the default export.
 * @param {NodePath} moduleExports The goog exports NodePath.
 * @param {string} moduleName The module name for the current file.
 */
const replaceGoogExportsWithDefault = (moduleExports, moduleName) => {
  const varIdentifier = jscs.identifier(moduleName.split('.').pop());
  const varDeclarator = jscs.variableDeclarator(varIdentifier, moduleExports.value.right);
  const varDeclaration = jscs.variableDeclaration('const', [varDeclarator]);
  copyComments(moduleExports.parent.value, varDeclaration);

  const exportDefaultDecl = jscs.exportDefaultDeclaration(varIdentifier);
  jscs(moduleExports.parent).insertAfter(exportDefaultDecl);

  jscs(moduleExports.parent).replaceWith(varDeclaration);
};


/**
 * Remove goog.module.declareLegacyNamespace statement.
 * @param {NodePath} root The root node.
 * @return {boolean} If the statement was removed.
 */
const removeLegacyNamespace = (root) => {
  let removed = false;

  // remove goog.module.declareLegacyNamespace calls - this can only be called within a goog.module
  const findLegacyNs = createFindCallFn('goog.module.declareLegacyNamespace');
  root.find(jscs.CallExpression, findLegacyNs).forEach((path, idx, paths) => {
    jscs(path).remove();
    removed = true;
  });

  return removed;
};


/**
 * Gets a temporary ES6 module name, when using a shim for the original.
 * @param {string} moduleName The original module name.
 * @return {string} The temp module name.
 */
const getTempModuleName = (moduleName) => `${moduleName}Temp`;


/**
 * Replace goog.module statement with goog.declareModuleId.
 * @param {NodePath} root The root node.
 * @param {boolean=} shimDefault If default exports should be shimmed. Defaults to false.
 * @return {string|undefined} The declared module name.
 */
const replaceModuleWithDeclareModuleId = (root, shimDefault = false) => {
  const isDefault = isDefaultExport(root);

  const findFn = createFindCallFn('goog.module');
  const moduleCalls = root.find(jscs.CallExpression, findFn);
  const path = moduleCalls.paths()[0];
  if (!path) {
    return undefined;
  }

  // Create the goog.declareModuleId statement.
  const moduleName = path.value.arguments[0].value;
  const newModuleName = isDefault && shimDefault ? getTempModuleName(moduleName) : moduleName;
  if (moduleName) {
    const declareModuleExpr = jscs.expressionStatement(createCall('goog.declareModuleId', [jscs.literal(newModuleName)]));

    // Preserve comments at the top of the file.
    copyComments(path.parent.value, declareModuleExpr);

    // Replace the goog.module statement with goog.declareModuleId.
    jscs(path.parent).replaceWith(declareModuleExpr);
  }

  if (moduleCalls.length > 1) {
    logger.warn(`Multiple goog.module statements detected. Please verify the transformation result.`);
  }

  return moduleName;
};


/**
 * Get the sort value for two goog.require/goog.requireType variable declarations.
 * @param {Node} a The first node.
 * @param {Node} b The second node.
 * @return {number} The sort value. Sorts goog.require above goog.requireType, then by required namespace.
 */
 const sortRequireNodes = (a, b) => {
  const aNamespace = a.expression.arguments[0].value;
  const bNamespace = b.expression.arguments[0].value;
  return aNamespace > bNamespace ? 1 : aNamespace < bNamespace ? -1 : 0
};


/**
 * Sort goog.require statements.
 * @param {Node} root The root node.
 */
const sortRequires = root => {
  const requires = root.find(jscs.ExpressionStatement, isGoogRequire)
      .nodes()
      .map(node => node.expression.arguments[0].value)
      .sort();

  root.find(jscs.ExpressionStatement, isGoogRequire).forEach((path, idx, arr) => {
    const callee = jscs.memberExpression(jscs.identifier('goog'), jscs.identifier('require'));
    const call = jscs.callExpression(callee, [jscs.literal(requires[idx])]);
    jscs(path).replaceWith(jscs.expressionStatement(call));
  });
};


/**
 * Get the sort value for two goog.require/goog.requireType variable declarations.
 * @param {Node} a The first node.
 * @param {Node} b The second node.
 * @return {number} The sort value. Sorts goog.require above goog.requireType, then by required namespace.
 */
const sortModuleRequireNodes = (a, b) => {
  const aIsRequire = a.declarations[0].init.callee.property.name === 'require';
  const bIsRequire = b.declarations[0].init.callee.property.name === 'require';

  if (aIsRequire === bIsRequire) {
    const aNamespace = a.declarations[0].init.arguments[0].value;
    const bNamespace = b.declarations[0].init.arguments[0].value;
    return aNamespace > bNamespace ? 1 : aNamespace < bNamespace ? -1 : 0
  }

  return aIsRequire ? -1 : 1;
};


/**
 * Sort goog.require variable declarations.
 * @param {Node} root The root node.
 */
const sortModuleRequires = root => {
  const requires = root.find(jscs.VariableDeclaration,
      (node) => isGoogModuleRequire(node) || isGoogModuleRequireType(node));
  if (requires.length) {
    const requireNodes = requires.nodes().slice().sort(sortModuleRequireNodes);
    requires.forEach((path, idx, arr) => {
      jscs(path).replaceWith(requireNodes[idx]);
    });
  }
};


/**
 * Sort goog.require variable declarations.
 * @param {Node} root The root node.
 */
const sortModuleRequireTypes = root => {
  const requires = root.find(jscs.VariableDeclaration,
      (node) => isGoogModuleRequireType(node));
  if (requires.length) {
    const requireNodes = requires.nodes().slice().sort(sortModuleRequireNodes);
    requires.forEach((path, idx, arr) => {
      jscs(path).remove([idx]);
    });

    const program = root.find(jscs.Program).get();
    const programBody = program.value.body;
    for (let i = 0; i < programBody.length; i++) {
      const current = programBody[i];
      if (!isGoogModule(current) && !isGoogDeclareLegacyNamespace(current) && !isGoogProvide(current) &&
          !isGoogRequire(current) && !isGoogModuleRequire(current)) {
        requireNodes.forEach((node, idx, arr) => {
          programBody.splice(i + idx, 0, node);
        })

        break;
      }
    }
  }
};


/**
 * Get all global references under a root node starting with a specified namespace.
 * @param {Node} root The root node.
 * @param {string} baseNs The base namespace to search for.
 * @return {!Array<string>} The global references, sorted in descending order.
 */
const getGlobalRefs = (root, baseNs) => {
  const memberExpressions = new Set();

  root.find(jscs.MemberExpression, {
    object: {
      name: baseNs
    }
  }).forEach((path) => {
    while (path.parent.value.type === 'MemberExpression'
        && !path.parent.value.computed
        && path.parent.value.property.name !== 'prototype') {
      path = path.parent;
    }

    memberExpressions.add(memberExpressionToString(path.value));
  });

  return [...memberExpressions];
};


/**
 * Replace global references to a module within a source file.
 * @param {Node} root The root node.
 * @param {string} moduleName The module name.
 */
const replaceSrcGlobals = (root, moduleName) => {
  // Add a goog.require statement then replace it with goog.module syntax.
  const varName = getUniqueVarName(root, moduleName);
  const assignedId = addModuleRequire(root, moduleName, varName);
  if (assignedId) {
    let instances;
    if (moduleName.indexOf('.') > -1) {
      instances = root.find(jscs.MemberExpression, createFindMemberExprObject(moduleName));
    } else {
      instances = root.find(jscs.Identifier, {name: moduleName});
    }

    // Find all instances of the global reference.
    instances.forEach((path) => {
      jscs(path).replaceWith(assignedId);
    });
  }
};


/**
 * Replace global references to a module within a test file.
 * @param {Node} root The root node.
 * @param {string} moduleName The module name.
 */
const replaceTestGlobals = (root, moduleName) => {
  // Add a goog.require statement for the module, if needed.
  addRequire(root, moduleName);

  // Reuse the assigned identifier if it's within the same describe() call.
  let assignedId;
  let lastDescribe;

  let instances;
  if (moduleName.indexOf('.') > -1) {
    instances = root.find(jscs.MemberExpression, createFindMemberExprObject(moduleName));
  } else {
    instances = root.find(jscs.Identifier, {name: moduleName});
  }

  // Find all instances of the global reference.
  instances.forEach((path) => {
    // Get the root describe() call, so we can find/create a goog.module.get statement for the module.
    const rootDescribe = getRootDescribe(path);
    if (rootDescribe) {
      // Get a unique variable name to assign the goog.module.get.
      const varName = getUniqueVarName(root, moduleName);

      // Find or create a goog.module.get statement for the module. If an existing gmg is found, this will
      // return the existing identifier for the module.
      if (!assignedId || rootDescribe !== lastDescribe) {
        lastDescribe = rootDescribe;
        assignedId = addGoogModuleGet(rootDescribe, moduleName, varName);
      }

      // If an identifier was returned, replace the global reference. If not, skip it and inform the user.
      if (assignedId && assignedId.type === 'Identifier') {
        jscs(path).replaceWith(assignedId);
      } else {
        logger.warn(`Couldn't reuse existing goog.module get for global reference to ${moduleName}`);
      }
    } else {
      // Couldn't find a root describe call, manual intervention needed.
      assignedId = undefined;
      lastDescribe = undefined;

      logger.warn(`Couldn't find root describe() for global reference to ${moduleName}`);
    }
  });
};


module.exports = {
  addDependency,
  addExports,
  addGoogModuleGet,
  addLegacyRequire,
  addModuleRequire,
  addRequire,
  getDependency,
  getDependencies,
  getGlobalRefs,
  getGoogModuleExports,
  getTempModuleName,
  hasDefaultExport,
  isClosureClass,
  isConst,
  isControllerClass,
  isDefaultExport,
  isDirective,
  isGoogDeclareLegacyNamespace,
  isGoogDeclareModuleId,
  isGoogDefine,
  isGoogModule,
  isESModuleFile,
  isGoogModuleFile,
  isModuleFile,
  isGoogModuleRequire,
  isGoogModuleRequireType,
  isGoogProvide,
  isGoogRequire,
  isGoogRequireCall,
  isGoogRequireTypeCall,
  isInterface,
  isPrivate,
  loadDeps,
  removeLegacyNamespace,
  replaceLegacyRequire,
  replaceModuleExportsWithEs6,
  replaceModuleWithDeclareModuleId,
  replaceSrcGlobals,
  replaceTestGlobals,
  sortRequireNodes,
  sortModuleRequireNodes,
  sortModuleRequires,
  sortModuleRequireTypes,
  sortRequires
};
